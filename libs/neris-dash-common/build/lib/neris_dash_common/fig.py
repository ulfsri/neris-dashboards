"""
Plotly figure builders with NERIS styling.

High-level chart builders that handle both data preparation and styling.
"""

import plotly.graph_objects as go
import plotly.express as px
import pandas as pd
from typing import Literal
from .utils import format_enum_text, format_hour
from .time_series import (
    TimeSeriesInterval,
    IntervalStyleConfig,
    get_style_config,
    RollingWindow,
)
from .colors import generate_hierarchical_colors
from .theme import DEFAULT_COLOR_SEQUENCE
from .chart_transforms import (
    build_tiered_type_nodes,
    sort_values_not_reported_last,
)

EMPTY_CHART_MESSAGE = "No records match the current filters"


__all__ = [
    "apply_neris_layout",
    "create_empty_chart",
    "create_time_series_trendline",
    "create_horizontal_stacked_bars",
    "create_bubble_chart",
    "create_hierarchical_chart",
    "create_contingency_bubble",
    "create_demographic_bars",
    "create_heatmap",
    "format_hour",
    "RollingWindow",
]


def apply_neris_layout(fig: go.Figure, height: int = 500):
    """Apply default NERIS figure styling to a figure"""
    fig.update_layout(
        hovermode="x unified",
        plot_bgcolor="rgba(0,0,0,0)",
        paper_bgcolor="rgba(0,0,0,0)",
        font=dict(size=12, family="Inter, Segoe UI, Arial"),
        margin=dict(l=20, r=20, t=40, b=20),
        height=height,
        autosize=False,  # Use fixed height to prevent resizing issues
    )
    return fig


def create_empty_chart(message: str = EMPTY_CHART_MESSAGE) -> go.Figure:
    """Create an empty chart with a message."""
    fig = go.Figure()
    fig.add_annotation(
        text=message,
        x=0.5,
        y=0.5,
        xref="paper",
        yref="paper",
        showarrow=False,
        font={"size": 16},
    )
    fig.update_layout(
        xaxis={"visible": False},
        yaxis={"visible": False},
    )
    return fig


def create_time_series_trendline(
    df: pd.DataFrame,
    *,
    date_column: str,
    count_column: str = "count",
    rolling_window: RollingWindow | None = None,
    interval: TimeSeriesInterval = "daily",
    y_axis_title: str = "Count",
):
    """Create a time series trendline figure from pre-aggregated data.

    This function expects pre-aggregated data (e.g., from DuckParquetRelation.time_series_counts)
    with one row per time period and a count column. It handles axis formatting and
    labeling appropriately for different time intervals.

    If `rolling_window` is provided, it expects the DataFrame to have a `rolling_window_avg`
    column (which can be generated by passing `rolling_window` to `time_series_counts`).

    Args:
        df: DataFrame with pre-aggregated time series data
        date_column: Name of the date column in the DataFrame
        count_column: Name of the count column (default: "count")
        rolling_window: Optional RollingWindow configuration
        interval: Time interval for the data (daily, weekly, monthly, quarterly)
        y_axis_title: Title for the y-axis

    Returns:
        Plotly figure with styled time series line chart
    """
    data = df.copy()
    if data.empty:
        return create_empty_chart()

    if data[date_column].dtype != "datetime64[ns]":
        data[date_column] = pd.to_datetime(data[date_column], errors="coerce")

    # Get styling configuration for the interval
    style_config: IntervalStyleConfig = get_style_config(interval)
    min_date = data[date_column].min()
    max_date = data[date_column].max()
    title: str = style_config.title_formatter(min_date, max_date)

    # Create line chart
    fig = px.line(
        data,
        x=date_column,
        y=count_column,
        title=title,
        color_discrete_sequence=["#007bff"],
    )
    fig.data[0].update(
        hovertemplate=f"<b>%{{x|{style_config.hover_date_format}}}</b><br>{count_column.title()}: %{{y:,}}<extra></extra>"
    )

    # Add rolling average if provided
    if rolling_window and "rolling_window_avg" in data.columns:
        label = (
            f"{rolling_window.window}-Day Avg"
            if rolling_window.include_current
            else f"Previous {rolling_window.window}-Day Avg"
        )
        fig.add_trace(
            go.Scatter(
                x=data[date_column],
                y=data["rolling_window_avg"],
                name=label,
                line=dict(color="rgba(128, 128, 128, 0.4)", width=6, dash="dash"),
                hovertemplate=f"<b>%{{x|{style_config.hover_date_format}}}</b><br>{label}: %{{y:.1f}}<extra></extra>",
            )
        )

    fig = apply_neris_layout(fig)
    fig.update_traces(
        line=dict(width=4),
        opacity=0.9,
        selector=dict(type="scatter", mode="lines"),
    )
    fig.update_yaxes(tickformat=",d", title_text=y_axis_title)
    fig.update_xaxes(
        title_text="",
        tickformat=style_config.x_tickformat,
        tickangle=45,  # Rotate labels vertically
    )
    fig.update_layout(
        autosize=True,
        height=None,
        margin=dict(l=80, b=100),
        dragmode="select",
        selectdirection="h",
        clickmode="event+select",
        showlegend=False,
        hoverlabel=dict(
            bgcolor="rgba(255, 255, 255, 0.9)",
            font_size=12,
            font_family="Inter, Segoe UI, Arial",
            font_color="#333333",
        ),
    )
    return fig


def create_bubble_chart(
    df: pd.DataFrame,
    *,
    x_col: str,
    y_col: str,
    size_col: str,
    size_max: int = 120,
    text_col: str | None = None,
    x_title: str = "",
    y_title: str = "",
    marker_color: str = "#2a9d8f",
    marker_opacity: float = 0.85,
    text_color: str = "white",
    text_size: int = 11,
    height: int = 500,
    margins: dict | None = None,
    hover_cols: list[str] | None = None,
    color: str | None = None,
    **kwargs,
):
    """Create a standardized bubble scatter with NERIS styling and enum tick labels."""
    if margins is None:
        margins = dict(l=120, r=40, t=40, b=120)

    # Use color if provided, otherwise marker_color
    final_marker_color = color if color else marker_color

    fig = px.scatter(
        df,
        x=x_col,
        y=y_col,
        size=size_col,
        size_max=size_max,
        text=text_col if text_col else None,
        hover_data={c: True for c in (hover_cols or [])},
        labels={x_col: x_title or x_col, y_col: y_title or y_col},
        **kwargs,
    )

    # Enum-style tick labels
    x_vals = df[x_col].unique().tolist()
    y_vals = df[y_col].unique().tolist()
    fig.update_xaxes(
        tickmode="array",
        tickvals=x_vals,
        ticktext=[format_enum_text(v) for v in x_vals],
    )
    fig.update_yaxes(
        tickmode="array",
        tickvals=y_vals,
        ticktext=[format_enum_text(v) for v in y_vals],
    )

    fig = apply_neris_layout(fig, height=height)
    fig.update_layout(autosize=True, margin=margins, hovermode="closest")
    fig.update_xaxes(
        tickangle=45,
        tickfont=dict(size=10),
        title_font=dict(size=13),
        title_standoff=30,
    )
    fig.update_yaxes(
        tickfont=dict(size=11), title_font=dict(size=13), title_standoff=40
    )

    fig.update_traces(
        marker=dict(
            color=final_marker_color,
            line=dict(width=2, color="white"),
            opacity=marker_opacity,
        ),
        textposition="middle center",
        textfont=dict(color=text_color, size=text_size),
        hovertemplate="%{y}<br>%{x}: %{marker.size:,}<extra></extra>",
    )

    return fig


def create_horizontal_stacked_bars(
    bars: list[tuple[str, pd.Series, list[str]]],
    *,
    height: int = 600,
    margin: dict | None = None,
) -> go.Figure:
    """Create a single figure with multiple horizontal stacked bars.

    bars: list of tuples (title, counts_series, colors_palette)
      - title: label for the bar (y-axis category)
      - counts_series: pd.Series indexed by category -> count (already sorted as desired)
      - colors_palette: list of color hex strings used cyclically (except NOT_REPORTED which is grey)
    """
    if margin is None:
        margin = dict(l=100, r=40, t=40, b=60)

    fig = go.Figure()

    for title, counts, colors in bars:
        if counts is None or counts.empty:
            continue
        for i, (category, value) in enumerate(counts.items()):
            if int(value) <= 0:
                continue
            formatted_category = format_enum_text(str(category))
            marker_color = (
                "#D3D3D3" if category == "NOT_REPORTED" else colors[i % len(colors)]
            )
            fig.add_trace(
                go.Bar(
                    name=f"{title} - {formatted_category}",
                    y=[title],
                    x=[int(value)],
                    orientation="h",
                    marker_color=marker_color,
                    text=[f"{int(value):,}<br>{formatted_category}"]
                    if value > 0
                    else [],
                    textposition="inside",
                    hovertemplate=f"<b>{title}</b><br>{formatted_category}: %{{x}}<extra></extra>",
                    showlegend=False,
                )
            )

    fig.update_layout(
        barmode="stack",
        height=height,
        autosize=True,
        showlegend=False,
        plot_bgcolor="rgba(0,0,0,0)",
        paper_bgcolor="rgba(0,0,0,0)",
        font=dict(size=10),
        margin=margin,
    )
    fig.update_xaxes(
        showgrid=True,
        gridwidth=1,
        gridcolor="rgba(128,128,128,0.2)",
        tickformat=",d",
    )
    fig.update_yaxes(showgrid=False)
    return fig


def create_hierarchical_chart(
    aggregated_df: pd.DataFrame,
    *,
    path_column: str = "path",
    count_column: str = "count",
    chart_type: Literal["sunburst", "treemap", "icicle"] = "sunburst",
    color_discrete_sequence: list[str] | None = None,
    color_discrete_map: dict[str, str] | None = None,
    base_color_map: dict[str, str] | None = None,
    height: int | None = None,
    root_label: str | None = None,
    initial_level: str | None = None,
    **kwargs,
) -> go.Figure:
    """Create hierarchical chart (sunburst, treemap, or icicle) from aggregated hierarchical path data.

    Expects pre-aggregated data: one row per unique path and a count column.
    """

    chart_functions = {
        "sunburst": px.sunburst,
        "treemap": px.treemap,
        "icicle": px.icicle,
    }

    # Expand paths into weighted list for build_tiered_type_nodes
    paths = []
    for _, row in aggregated_df.iterrows():
        paths.extend([row[path_column]] * int(row[count_column]))

    if not paths:
        return create_empty_chart()

    plot_df = build_tiered_type_nodes(paths, root_label=root_label)

    if base_color_map:
        color_discrete_map = generate_hierarchical_colors(
            plot_df["ids"].tolist(), base_color_map
        )

    if color_discrete_sequence is None:
        color_discrete_sequence = DEFAULT_COLOR_SEQUENCE

    chart_func = chart_functions[chart_type]

    # Combine default arguments with kwargs
    px_args = {
        "data_frame": plot_df,
        "ids": "ids",
        "values": "values",
        "names": "labels_with_counts",
        "parents": "parents",
        "color": "ids" if color_discrete_map else None,
        "color_discrete_sequence": color_discrete_sequence,
        "color_discrete_map": color_discrete_map,
    }
    px_args.update(kwargs)

    fig = chart_func(**px_args)

    fig = apply_neris_layout(fig)
    fig.update_layout(autosize=True, height=height)

    # Set initial drill-down level if provided
    if initial_level and initial_level in plot_df["ids"].values:
        fig.update_traces(level=initial_level)

    trace_updates = {
        "textinfo": "label",
        "textfont": dict(size=14, color="white"),
        "hovertemplate": "%{customdata}<extra></extra>",
        "customdata": plot_df["hover_text"],
        "marker": dict(line=dict(width=1, color="white")),
    }

    if chart_type == "sunburst":
        trace_updates["insidetextorientation"] = "horizontal"

    fig.update_traces(**trace_updates)
    return fig


def create_contingency_bubble(
    aggregated_df: pd.DataFrame,
    *,
    row_column: str,
    col_column: str,
    count_column: str = "count",
    x_title: str = "",
    y_title: str = "",
    height: int = 400,
    **kwargs,
) -> go.Figure:
    """Create bubble chart from aggregated contingency table data.

    Expects pre-aggregated data one row per row/column combination and a count column.
    """
    if aggregated_df.empty:
        return create_empty_chart()

    # Sort to put NOT_REPORTED last
    df = aggregated_df.copy()
    df[row_column] = pd.Categorical(
        df[row_column],
        categories=sort_values_not_reported_last(df[row_column].unique().tolist()),
        ordered=True,
    )
    df[col_column] = pd.Categorical(
        df[col_column],
        categories=sort_values_not_reported_last(df[col_column].unique().tolist()),
        ordered=True,
    )
    df = df.sort_values([row_column, col_column])

    # Filter out zero counts
    df = df[df[count_column] > 0]

    if df.empty:
        return create_empty_chart()

    return create_bubble_chart(
        df,
        x_col=col_column,
        y_col=row_column,
        size_col=count_column,
        text_col=count_column,
        x_title=x_title or format_enum_text(col_column),
        y_title=y_title or format_enum_text(row_column),
        height=height,
        **kwargs,
    )


def create_demographic_bars(
    aggregated_df: pd.DataFrame,
    *,
    demographic_columns: list[str],
    count_column: str = "count",
    colors: list[str] | None = None,
    height: int = 600,
) -> go.Figure:
    """Create stacked horizontal bar chart from aggregated demographic data.

    Expects pre-aggregated data with one row per unique combination of demographic values and a count column.
    """
    if aggregated_df.empty:
        return create_empty_chart()

    if colors is None:
        colors = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b"]

    bars = []
    for col in demographic_columns:
        # Aggregate counts by this demographic column
        counts = aggregated_df.groupby(col)[count_column].sum()

        # Sort to put NOT_REPORTED last
        sorted_index = sort_values_not_reported_last(counts.index.tolist())
        counts = counts.reindex(sorted_index, fill_value=0)

        bars.append((format_enum_text(col), counts, colors))

    return create_horizontal_stacked_bars(bars, height=height)


def create_heatmap(
    aggregated_df: pd.DataFrame,
    *,
    x_column: str,
    y_column: str,
    x_order: list,
    y_order: list,
    count_column: str = "count",
    colorscale: str | list[list] = "Viridis",
    height: int = 500,
    x_label_formatter: callable = str,
    y_label_formatter: callable = str,
) -> go.Figure:
    """Create a heatmap from aggregated contingency data.

    Expects pre-aggregated data: one row per unique x/y combination and a count column.
    x_order and y_order must contain all values present in the data (missing combinations will be 0).
    Designed to support cross-filtering interactions.
    """
    # Verify all values in data are present in order lists
    x_values_in_data = set(aggregated_df[x_column].unique())
    y_values_in_data = set(aggregated_df[y_column].unique())
    x_values_in_order = set(x_order)
    y_values_in_order = set(y_order)

    missing_x = x_values_in_data - x_values_in_order
    missing_y = y_values_in_data - y_values_in_order

    if missing_x:
        raise ValueError(
            f"x_order is missing values present in data: {missing_x}. "
            "x_order must include all x_column values."
        )
    if missing_y:
        raise ValueError(
            f"y_order is missing values present in data: {missing_y}. "
            "y_order must include all y_column values."
        )

    # Pivot table - pandas pivot_table is efficient for this size of data
    pivot_df = aggregated_df.pivot_table(
        index=y_column, columns=x_column, values=count_column, fill_value=0
    )

    # Reindex to ensure all ordered values are present (fills missing with 0)
    pivot_df = pivot_df.reindex(index=y_order, columns=x_order, fill_value=0)

    num_cols = len(x_order)
    num_rows = len(y_order)
    # TODO move this to some kind of configuration
    grid_color = "rgba(0,0,0,0.3)"
    cell_border_color = "rgba(0,0,0,0.5)"

    # Prepare customdata for hover (x, y labels)
    customdata = [
        [[x_label_formatter(x), y_label_formatter(y)] for x in x_order] for y in y_order
    ]

    # TODO: This is quite verbose, and could likely be shortened, modularized,
    # and/or made to fit better with some kind of NERIS styling config object(s).
    # Leaving that for future work with the amplification team.
    fig = go.Figure(
        data=go.Heatmap(
            z=pivot_df.values,
            x=list(range(num_cols)),
            y=list(range(num_rows)),
            colorscale=colorscale,
            text=pivot_df.values,
            texttemplate="%{text:,}",
            textfont=dict(size=12, color="white"),
            hovertemplate="<b>%{customdata[1]}</b><br>%{customdata[0]}<br>Count: %{z:,}<extra></extra>",
            customdata=customdata,
            showscale=False,
            xgap=2,  # Gap between columns for table-like appearance
            ygap=2,  # Gap between rows for table-like appearance
        ),
        layout=go.Layout(
            xaxis=go.layout.XAxis(
                title="",
                tickmode="array",
                tickvals=list(range(num_cols)),
                ticktext=[x_label_formatter(x) for x in x_order],
                tickangle=45 if num_cols > 7 else 0,
                showgrid=True,
                gridwidth=2,
                gridcolor=grid_color,
                showline=True,
                linewidth=2,
                linecolor=cell_border_color,
                range=[-0.5, num_cols - 0.5],
                fixedrange=True,  # Disable zoom
            ),
            yaxis=go.layout.YAxis(
                title="",
                tickmode="array",
                tickvals=list(range(num_rows)),
                ticktext=[y_label_formatter(y) for y in y_order],
                autorange="reversed",
                showgrid=True,
                gridwidth=2,
                gridcolor=grid_color,
                showline=True,
                linewidth=2,
                linecolor=cell_border_color,
                range=[num_rows - 0.5, -0.5],
                fixedrange=True,  # Disable zoom
            ),
            autosize=True,
            dragmode="select",  # Enable box selection
            selectdirection="any",  # Allow any direction selection
            clickmode="event+select",  # Enable click and select events for cross-filtering
        ),
    )

    fig = apply_neris_layout(fig, height=height)

    # Re-apply settings that apply_neris_layout may override
    fig.update_layout(
        autosize=True,  # Restore autosize
        dragmode="select",  # Restore selection mode
        selectdirection="any",
        clickmode="event+select",  # Ensure click and select events are enabled
        # Add more margin for tick labels to prevent cutoff
        margin=dict(l=60, r=40, t=40, b=80),
    )

    # Re-apply grid settings after apply_neris_layout (it may override them)
    # Make grid lines more visible for table-like appearance
    fig.update_xaxes(
        showgrid=True,
        gridwidth=2,
        gridcolor=grid_color,
        showline=True,
        linewidth=2,
        linecolor=cell_border_color,
        # Add more space for rotated labels
        tickangle=45 if num_cols > 7 else 0,
        tickfont=dict(size=11),
    )
    fig.update_yaxes(
        showgrid=True,
        gridwidth=2,
        gridcolor=grid_color,
        showline=True,
        linewidth=2,
        linecolor=cell_border_color,
        # Ensure Y-axis labels have enough space
        tickfont=dict(size=11),
    )

    return fig
